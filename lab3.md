应该说，目前位置我学习的所有的一切都是模型。

模型可以用文字表述，可以用公式表述。

进程这套东西，操作系统这套东西也不过是一种模型。

写代码可以将任何一种模型描述的东西创造出来，操作系统也是写代码可以创造出来的模型的一种而已，没有什么特殊的，说到底操作系统还是软件，只不过和硬件有那么一点关联。软件的部分理解概念就好了，然后清楚我们是用什么数据结构来表示的。硬件的部分需要结合硬件架构来理解。

我们创建进程的办法就是写一个PCB，然后放到就绪队列里面。

这里我们实现的就绪队列就一个，没有分成多级，是为了降低难度。

然后切换进程运行进程靠的就是时钟中断。

而在我们的模型中，中断又算是异常的一种。

异常只不过是一种概念。

本来CPU正常只需要按照提前写好的指令一步一步运行就好了，PC不断+4+4，遇到跳转指令就跳到不同的取指令地址。指令也是需要地方存的， 存取指令的内存和我们实际上用的内存是放在一起的。这里我们说指令，实际上过于具体化了，应该说程序。程序就是一系列指令的集合。其实这么说也不严谨，一系列指令的集合可以叫做程序，但是程序往往还可以用其他的语言来表示。程序可以是任何语言，用文字表述也可以，只不过程序员把需求整理成文字逻辑，把文字逻辑写成某种语言的程序，编译器将这种语言的程序翻译成汇编指令，汇编器又翻译成二进制机器码而已。

进程不过是运行的程序

进程有三种状态，运行，阻塞，就绪，

运行就是CPU正在运行这个进程，阻塞就是因为等待IO或者别的进程的信息而不得不停止，就绪就是可以继续运行，但是CPU正在被别的进程占着。

CPU正在运行这个进程是怎么回事呢？

就是CPU的PC寄存器指着这个进程的程序，当前所有可用的寄存器上下文也是这个进程的上下文。

进程不过是运行的程序，程序是静态的，不过是一段代码，但是进程是动态的。一段程序从开始运行到结束，如果有一个进度条的话，进程可以运行到百分之一，还可以运行到百分之五十。

进程可以有很多的状态，从百分之一到百分之五十，虽然不是无数种，因为CPU是一步一步运行的，这个过程是离散的，但是一段常见的有用的程序可以有成千上万种状态。区分这些状态的，就是32个寄存器的值（包括了PC寄存器），寄存器的值不停的变换着，就代表进程正不断的前进。

那么我们如何做到把不同的进程不停地切换呢？就需要保存进程的状态，进程从CPU换下来之后，运行另一些进程，然后又把进程换回去，换回去之后的进程应该和换下来之前的进程一模一样，如何保证一模一样，需要我们保存上下文（无非是32个寄存器的值），这个上下文放在哪里呢？放在进程控制块里面。进程控制块又在哪里？在内核空间。

进程控制块有着某一个进程的全部信息。我们用一个结构体来表示。其中有一个env_tf就是用来存上下文的。除了上下文，还有id，parent_id,status,env_pgdir,env_pri,env_link,env_sched_link等成员。

id用来当作唯一表示，内核空间页目录地址代表了该进程的地址空间，但是这种信息只有CPU处于内核态的时候才能用，还有优先级，是调度的时候用的，剩下两个结构体是为了方便构造空闲队列和就绪队列

env_init，初始化空闲队列和就绪队列，一开始所有进程控制块都在空闲队列，就绪队列没有进程。

有了PCB的基本构造，那么创建进程的过程其实就是申请一个空闲的PCB，从空闲队列拿出来，然后填好基本信息，放到就绪队列里面，

其中基本信息就包括上面说的，主要有两个重要的部分

- env_pgdir,这个是页目录，每个进程的页目录是不一样的，要专门分配一个物理页来做页目录，然后初始化这个页目录，其实也就是初始化这个进程的地址空间，因为地址空间中有一些内容是所有进程共享的，是原本内核空间的内容，包括物理页控制块，进程控制块，还有一部分空间是专门放页表的，这个也需要初始化，主要是实现自映射就好。
- 加载程序，这个加载程序其实也是对env_pgdir动手脚，前面的初始化，其实就是在地址空间中加了一些内容，这个加载程序其实也是把程序加载到地址空间中，具体加载到哪里？是二进制文件说了算。
- 剩下的就是一些id，asid，parent_id,pri等一些简单的内容

中断和异常很重要。对于我们理解lab3来讲，其实最关心的就是时钟中断，时钟中断时异常里面的一种，所以我们需要了解异常。MIPS CPU处理异常的步骤：

- 设置EPC指向从异常返回的地址
- 设置EXL位，强制CPU进入内核态。（这里可能不理解什么时内核态什么时用户态，其实就是我们认为规定的CPU的两种状态，用户态不能做一些内核态才被允许做的事情，比如访问内核空间，我们规定了寄存器的两个位用来标记CPU处于内核态还是用户态。我们切换内核态还是用户态也只需要修改这两个寄存器的值就可以）
- 设置Cause寄存器，用于记录异常发生的原因。
- 从异常入口位置取值，交给软件处理（这个异常入口位置是固定的，人为规定的，我们链接的时候要爸异常处理程序连接到规定的入口位置）
- 异常处理程序其实是一个分发异常的程序：检测发生了哪种异常，并且调用相应的异常处理程序，异常分发代码的作用流程：
  - 使用SAVE_ALL宏将当前上下文保存到内核的异常栈中，==这个SAVE_ALL相当重要，因为进入内核态之后，所有的寄存器的值是很可能会变的，我们在内核态的时候有很多地方需要用到当前进程的上下文，所以一定要放到内核的异常栈当中，用的时候到异常栈里面去找==
  
    
  
  - 清楚Status寄存器中的UM、EXL、IE位，以保持处理器处于内核态（UM==0）、关闭中断且允许嵌套异常
  
  - 将Cause寄存器的内容拷贝到t_0寄存器中
  
  - 取得Cause寄存器中的2~6位，也就是对应的异常码，这是区别不同异常的重要标志
  
  - 以得到的异常码作为索引在exception_handlers数组中找到对应的中断处理函数
  
  - 跳转到对应的中断处理函数中

时钟中断的中断处理函数是handle_int函数

最后会跳转到schedule调度函数

在schedule调度函数中，会根据不同算法，决定下一个要运行的进程是什么。然后使用env_run

env_run 的时候把当前之前SAVE_ALL存到内核异常栈里面的上下文全部放到env_tf里面，

然后切换curenv

然后把切换后的上下文恢复