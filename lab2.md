Page_list 的定义：

LIST_HEAD(Page_list,Page)

这个结构体里面有一个成员，就是一个指向第一页，Page的指针

struct Page_list page_free_list;

我之前使用头结点都是用相同的结构体，但是这里似乎是定义了另一个特殊的结构体。

#### page2pa（pp）宏的含义

```c++
#define page2pa(pp) ((pp - pages) << PAGE_SHIFT)// 计算物理地址
```

将pp指向的页映射到物理地址。

PAGE_SHIFT=log2(PAGE_SIZE)

#### KADDR(pa)宏的含义

```c++
#define KADDR(pa) ((void *)((char *)(pa) + KERNBASE))  // 物理→虚拟地址转换
```

将pa从物理地址转换成虚拟地址

#### page2kva（pp）宏的含义

```
#define page2kva(pp) ((void *)((char *)KADDR(page2pa(pp))))
```

将C管理的page页地址映射到内核虚拟地址（0x00000000-0x100000000)

请注意，C管理的page页的数据结构应该也是在内核虚拟地址当中的（0x80000000-0x80400000），但是这两个内核虚拟地址是有区别的，一个是数据结构的地址，一个是真正的页的地址。

所管理的页是包含了所有地址空间的，但是管理页用的数据结构只占用很小的一部分空间。

#### 总结物理内存管理部分

物理内存管理旨在使用一个Page数组映射所有的物理内存，记录该页物理内存的被引用数，同时使用一个page_free_list管理一个空闲物理内存，关键在于理解数据结构以及各种数据的虚拟内存和物理内存的关系。

pages数组的size为npage，npage就是总共的页数，单元是struct Page，struct Page包括一个pp_link 结构体和一个pp_ref计数器，记录这块物理内存的被引用数，如果被引用数为0，说明这一页内存是空闲的。

刚开始看可能会有struct page中为什么没有对应的物理地址这样的疑惑,其实Page[i]对应的物理地址就是i*PAGE_SIZE.是直接映射.

需要注意的是,Page结构体中有一个pp_link结构体,这个结构体是为了实现双链表的结构,但是我们在理解pages数组的时候就只需要理解成数组就可以了,pp_link结构体是为空闲链表准备的。

之所以这么设置是为了便于创建空闲链表，在创建空闲链表的时候，只需要使用LIST_HEAD宏，定义一种特殊的头结点结构体，该结构体只包含一个成员，那就是一个指向链表第一个元素的指针。

注意pp_link模块的结构，其中包含两个指针，le_next和le_prev，一定要注意这两个指针的含义不是对称的，le_next中记录下一个链表结构体的地址，而le_prev记录的是上一个结构体的le_next块的地址。

之所以不直接指向上一个结点，似乎是因为头结点的特殊性？

这种设计似乎对于链表的反向遍历不太方便，但是便于从链表中插入和删除结点。

#### 对于mips_init相关C代码在内存中位置的思考

指导书中提到，在物理空间0x400000的前面，存放着操作系统内核的代码和定义的全局变量或数组，也就是说，mips_init的相关代码是放在物理地址0x400000的前面的，但是，在运行mips_init的时候，产生的数据是在物理地址0x400000之后的，比如说Pages数组和空闲链表头的地址。这里其实可以从pages数组的分配代码中看出来。

freemem随着分配的地址空间增加而增加。

一定要注意理解pages数组相关的不同含义的地址的关系。

pages数组本身存放在0x80400000之后，这个地址是虚拟地址，使用page2pa宏可以将pages数据本身的虚拟地址转换成对应的物理地址。也就是说，在page2pa（page)到page2pa(page)+sizeof(struct Page)这一块物理地址上，存放着page[0]的pp_link数据和pp_res数据。而page[0]映射到物理地址是0x0~PAGESIZE，page[i]映射的物理空间是[i\*PAGE_SIZE,i\*PAGE_SIZE+PAGE_SIZE)，

i*PAGE_SIZE在实际代码中往往可以写成i<<PAGE_OFFSET，PAGE_OFFSET一般是12；

虚拟地址映射到物理地址是规定好的，其中0x80000000以后是可以直接使用的，这部分的映射可以用硬件实现，我们的初始化C代码就是在使用这部分空间，但是0x8000000以下的部分是不可以使用的，因为我们还没有建立好TLB。

### 虚拟内存管理

